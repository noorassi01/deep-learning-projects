# -*- coding: utf-8 -*-
"""lab3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1X6WWpFfm0MbVFttBaECXjndCTd4mJiKM

<a href="https://colab.research.google.com/github/wingated/cs474_labs_f2019/blob/master/DL_Lab3.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>

# Lab 3: Intro to CNNs and DNNs

## Objectives

* Build and train a deep conv net
* Explore and implement various initialization techniques
* Implement a parameterized module in Pytorch
* Use a principled loss function

## Video Tutorial
[https://youtu.be/3TAuTcx-VCc](https://youtu.be/3TAuTcx-VCc)

## Deliverable
For this lab, you will submit an ipython notebook via learningsuite.
This is where you build your first deep neural network!

For this lab, we'll be combining several different concepts that we've covered during class,
including new layer types, initialization strategies, and an understanding of convolutions.

## Grading Standards:
* 20% Part 0: Successfully followed lab video and typed in code
* 20% Part 1: Re-implement Conv2D and CrossEntropy loss function
* 20% Part 2: Implement different initialization strategies
* 10% Part 3: Print parameters, plot train/test accuracy
* 10% Reach 85% validation accuracy from parts 1-3
* 10% Part 4: Convolution parameters quiz
* 10% Tidy and legible figures, including labeled axes where appropriate
___

### Part 0
Watch and follow video tutorial:

[https://youtu.be/3TAuTcx-VCc](https://youtu.be/3TAuTcx-VCc)

**TODO:**

* Watch tutorial

**DONE:**
"""

!pip3 install torch
!pip3 install torchvision
!pip3 install tqdm

from torch.nn.parameter import Parameter
import pdb

import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
from torch.utils.data import Dataset, DataLoader
import numpy as np
import matplotlib.pyplot as plt
from torchvision import transforms, utils, datasets
from tqdm import tqdm
from torch.nn.parameter import Parameter
import pdb

assert torch.cuda.is_available(), "You need to request a GPU from Runtime > Change Runtime"

# Use the dataset class you created in lab2
class FashionMNISTProcessedDataset(Dataset):
  def __init__(self, root,train=True):
    self.data = datasets.FashionMNIST(root, train=train,
                                      transform=transforms.ToTensor(),
                                      download=True)
  def __getitem__(self,i):
    x, y = self.data[i]
    #pdb.set_trace()
    return x, y

  def __len__(self):
    return len(self.data)

"""___

### Part 1
Re-implement a Conv2D module with parameters and a CrossEntropy loss function.

**TODO:**

* CrossEntropyLoss
* Conv2D

**DONE:**

___

### Part 2
Implement a few initialization strategies which can include Xe initialization
(sometimes called Xavier), Orthogonal initialization, and uniform random.
You can specify which strategy you want to use with a parameter.



Helpful links include:
*  [Orthogonal Initialization](https://hjweide.github.io/orthogonal-initialization-in-convolutional-layers) (or the original paper: http://arxiv.org/abs/1312.6120)
*  http://andyljones.tumblr.com/post/110998971763/an-explanation-of-xavier-initialization

**TODO:**
* Parameterize custom Conv2D for different initilization strategies
* Xe
* Orthogonal
* Uniform

**DONE:**


"""

class CrossEntropyLoss(nn.Module):
  def __init__(self, weight=None, size_average=None, ignore_index=- 100, reduce=None, reduction='mean', label_smoothing=0.0):
    self.__dict__.update(locals())
    super(CrossEntropyLoss, self).__init__()

  def forward(self, y_hat, y_truth):
    log_props = y_hat[torch.arange(len(y_truth)), y_truth]
    penalty = -(log_props - torch.logsumexp(y_hat, dim=-1))
    return torch.mean(penalty)


class Conv2d(nn.Module):
  def __init__(self, in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True, padding_mode='zeros', init_type='xavier'):
    self.__dict__.update(locals())
    super(Conv2d, self).__init__()

    #(out, in, k,k)
    self.weight = Parameter(torch.Tensor(out_channels,
                               in_channels,
                               kernel_size[0],
                               kernel_size[1]))
    self.bias = Parameter(torch.Tensor(out_channels))

    #self.weight.data.uniform_(-1,1)
    self.bias.data.uniform_(0,0)


    if init_type == 'xavier':
      self.bias.data.zero_()
      fan = self.weight.size(1)
      limit = 1 / np.sqrt(fan)
      self.weight.data.uniform_(-limit, limit)
    elif init_type == 'uniform':
      self.weight.data.unifrom_(-1,1)
    else: #Orthogonal
      X = np.random.random((out_channels, in_channels, *kernel_size)).astype(np.float32)
      U,_,Vt = np.linalg.svd(X, full_matrices=False)
      if len(X) > len(X[0]):
        W = U
      else:
        W = Vt
      W = X.reshape(out_channels, in_channels, *kernel_size)
      self.weight.data = torch.tensor(W).float()

    #intialize
  def forward(self, x):
    return F.conv2d(x, self.weight, self.bias, self.stride, self.padding, self.dilation, self.groups)

class ConvNetwork(nn.Module):
  def __init__(self, dataset):
    super(ConvNetwork, self).__init__()
    x, y = dataset[0]
    c, h, w = x.size()
    output = 10

    self.net = nn.Sequential(
        Conv2d(in_channels=c, out_channels=output, kernel_size=(3,3), padding=(1,1)),
        nn.ReLU(),
        Conv2d(in_channels=10, out_channels=10, kernel_size=(3,3), padding=(1,1)),
        nn.ReLU(),
        Conv2d(in_channels=10, out_channels=64, kernel_size=(3,3), padding=(1,1)),
        nn.ReLU(),
        Conv2d(in_channels=64, out_channels=64, kernel_size=(3,3), padding=(1,1)),
        nn.ReLU(),
        Conv2d(in_channels=64, out_channels=128, kernel_size=(3,3), padding=(1,1)),
        nn.ReLU(),
        Conv2d(in_channels=128, out_channels=128, kernel_size=(3,3), padding=(1,1)),
        nn.ReLU(),
        Conv2d(in_channels=128, out_channels=256, kernel_size=(3,3), padding=(1,1)),
        nn.ReLU(),
        Conv2d(in_channels=256, out_channels=output, kernel_size=(28,28), padding=(0,0)),
    )

  def forward(self, x):
    return self.net(x).squeeze(2).squeeze(2)

# Initialize Datasets
train_dataset = FashionMNISTProcessedDataset('/tmp/fashionmnist', train=True)
val_dataset = FashionMNISTProcessedDataset('/tmp/fashionmnist', train = False)

# Initialize DataLoaders
train_loader = DataLoader(train_dataset, batch_size=42, pin_memory=True)
val_loader = DataLoader(val_dataset, batch_size=42, pin_memory=True)

# Initialize Model
model = ConvNetwork(train_dataset)
model = model.cuda()

# Initialize Objective and Optimizer and other parameters
objective = CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=1e-4)

# Run your training and validation loop and collect stats
losses = []
validations = []
accuracies = []
val_scores = []
for epoch in range(1):
  loop = tqdm(total=len(train_loader), position=0, leave=False)

  for batch, (x, y_truth) in enumerate(train_loader):
    x, y_truth = x.cuda(non_blocking=True), y_truth.cuda(non_blocking=True)

    optimizer.zero_grad()
    y_hat= model(x)

    loss= objective(y_hat, y_truth)

    loss.backward()

    losses.append(loss.item())

    guesses = torch.softmax(y_hat, dim=1).argmax(dim=1)

    accuracy = (guesses == y_truth).float().mean()
    accuracies.append(accuracy.item())
    loop.set_description('epoch:{} loss:{:.4f} accuracy:{:.3f}'.format(epoch, loss.item(), accuracy))
    loop.update(1)

    optimizer.step()

    if batch % 500 == 0:
      val = np.mean([objective(model(x.cuda()), y.cuda()).item()
                      for x, y in val_loader])
      validations.append((len(losses), val))

      val_score = np.mean([(model(x.cuda()).argmax(1) == y.cuda()).float().mean().item() for x, y in val_loader])
      val_scores.append((len(losses), val_score))

  loop.close()
  val_score = np.mean([(model(x.cuda()).argmax(1) == y.cuda()).float().mean().item() for x, y in val_loader])
  val_scores.append((len(losses), val_score))


a, b = zip(*validations)
plt.plot(losses, label='train')
plt.plot(a, b, label='val')
plt.title("Loss")
plt.legend()
plt.show()

"""
___

### Part 3
Print the number of parameters in your network and plot accuracy of your training and validation
set over time. You should experiment with some deep networks and see if you can get a network
with close to 1,000,000 parameters.

Once you've experimented with multiple network setups and the different initialization strategies, plot the best-performing experiment here. You should be able to exceed 85% accuracy on the validation set.

**TODO:**
* Experiment with Deep Networks
* Plot accuracy of training and validation set over time
* Print out number of parameters in the model
* Plot experiment results with 85% or better validation accuracy

**DONE:**
"""

# Go back up and try a few different networks and initialization strategies
# Plot loss if you want
# Plot accuracy
a,b = zip(*val_scores)
plt.plot(accuracies, label="Train")
plt.plot(a, b, label='val')
plt.legend()
plt.title("Accuracy")
plt.show()

# Compute and print the number of parameters in the model
params = 0

for p in model.parameters():
  param = 1
  for x in p.size():
    param = param * x
  params = params + param

print(params)

"""___

### Part 4
Learn about how convolution layers affect the shape of outputs, and answer the following quiz questions. Include these in a new markdown cell in your jupyter notebook.


*Using a Kernel size of 3×3 what should the settings of your 2d convolution be that results in the following mappings (first answer given to you)*

* (c=3, h=10, w=10) ⇒ (c=10, h=8, w=8) : (out_channels=10, kernel_size=(3, 3), padding=(0, 0))
* (c=3, h=10, w=10) ⇒ (c=22, h=10, w=10) : **(out_channels=22, kernel_size=(3, 3), padding=(1,1))**
* (c=3, h=10, w=10) ⇒ (c=65, h=12, w=12) : **(out_channels=65, kernel_size=(3, 3), padding=(2,2))**
* (c=3, h=10, w=10) ⇒ (c=7, h=20, w=20) : **(out_channels=7, kernel_size=(3, 3), padding=(6,6))**

*Using a Kernel size of 5×5:*)

* (c=3, h=10, w=10) ⇒ (c=10, h=8, w=8) : (out_channels=10, kernel_size=(5, 5), padding=(1, 1))
* (c=3, h=10, w=10) ⇒ (c=100, h=10, w=10) : **(out_channels=100, kernel_size=(5,5), padding=(2,2))**
* (c=3, h=10, w=10) ⇒ (c=23, h=12, w=12) : **(out_channels=23, kernel_size=(5,5), padding=(3,3))**
* (c=3, h=10, w=10) ⇒ (c=5, h=24, w=24) : **(out_channels=5, kernel_size=(5,5), padding=(9,9))**

*Using Kernel size of 5×3:*

* (c=3, h=10, w=10) ⇒ (c=10, h=8, w=8) : **(out_channels=10, kernel_size=(5,3), padding=(1,0))**
* (c=3, h=10, w=10) ⇒ (c=100, h=10, w=10) : **(out_channels=100, kernel_size=(5,3), padding=(2,1))**
* (c=3, h=10, w=10) ⇒ (c=23, h=12, w=12) : **(out_channels=23, kernel_size=(5,3), padding=(3,2))**
* (c=3, h=10, w=10) ⇒ (c=5, h=24, w=24) : **(out_channels=5, kernel_size=(5,3), padding=(9,8))**

*Determine the kernel that requires the smallest padding size to make the following mappings possible:*

* (c=3, h=10, w=10) ⇒ (c=10, h=9, w=7) : **(out_channels=10, kernel_size=(2,4), padding=(0,0))**
* (c=3, h=10, w=10) ⇒ (c=22, h=10, w=10) : **(out_channels=22, kernel_size=(1,1), padding=(0,0))**

**TODO:**

* Answer all the questions above

**DONE:**

"""

# Write some test code for checking the answers for these problems (example shown in the video)
c = nn.Conv2d(3, 65, kernel_size=(3,3), padding=(2,2))
print(c(torch.zeros(1,3,10,10)).size())

c = nn.Conv2d(3, 10, kernel_size=(2,4), padding=(0,0))
print(c(torch.zeros(1,3,10,10)).size())